#个人方向 
#开放实验 
#李昊康
# 坚持开放实验

# 坚持创新创业方面竞赛

# 坚持“先实物，再展示”

# 目前流程
1. 还是最好从一个小车入门吧，简易的小车+简易的机械臂+视觉，基本能接触一遍，包括算法实现、实现的问题、改进的措施；后续硬件到位再升级，
	1. [Google Gemini](https://gemini.google.com/app/e35edcf923e673a6?hl=zh-cn)
		1. 这是一个非常明智且高效的策略！
	
	从一个 **“小车+简易机械臂+视觉”** 的集成平台入手，你可以用有限的硬件资源，跑通你所学的 **所有核心技术栈（STM32、ROS、规划、控制、视觉）**，形成一个完整的项目闭环。这比单独深入钻研任何一个领域都要更有价值，因为它直接模拟了 RoboMaster 这类比赛的系统复杂度。
	
	## 项目规划：基础集成平台 (MVP)
	
	这个项目可以命名为 **“ROS-FSM 驱动的简易协作机器人 (Mobile Manipulator)”**。
	
	|平台组件|现有资源利用|核心技术目标|
	|---|---|---|
	|**底盘**|STM32F103 + MG370/520 DC 电机 + 编码器|**实时速度控制、里程计、ROS 通信桥接**|
	|**机械臂**|简易舵机 Demo 或 DC 电机 Demo|**运动学建模、ROS MoveIt! 规划、轨迹跟踪**|
	|**视觉/上位机**|Raspberry Pi 4B + 笔记本 VM + 单目摄像头|**目标识别、坐标变换、高层任务决策**|
	|**核心算法**|PID 控制、A∗ 规划、OpenCV 目标检测|**控制与规划的软硬件集成**|
	
	## 阶段划分与技术目标（项目闭环路线）
	
	我们将项目分为三个紧密相连的阶段，每个阶段都致力于实现一个“**技术闭环**”。
	
	### 阶段一：底盘运动与底层通信闭环
	
	**目标：** 实现 ROS 命令底盘移动，并能接收底盘状态。这是所有上层规划的基础。
	
	|目标任务|核心技术栈|实现问题 → 改进措施|
	|---|---|---|
	|**1. 电机实时 PID 调速**|STM32 C/C++|**问题：** PID 速度环震荡或超调大。→ **改进：** 学习 PID **积分分离/抗饱和**等工程调参技巧。|
	|**2. 里程计与 IMU 姿态估计**|STM32 C/C++ + IMU（需添置）|**问题：** 简单积分 IMU 数据漂移严重。→ **改进：** 实现**互补滤波**，将 IMU 和编码器数据融合。|
	|**3. ROS−STM32 通信**|Python/ros_serial|**问题：** 串口通信丢包、延迟大。→ **改进：** 学习**校验和**机制，使用 **FreeRTOS 任务**将通信与控制解耦（你已经计划）。|
	|**4. ROS Odometry 发布**|ROS/C++|**问题：** Rviz 中的底盘 TF 坐标系跳动。→ **改进：** 确保 Odometry 话题和 TF 坐标变换的发布频率和格式正确。|
	
	### 阶段二：机械臂规划与视觉感知闭环
	
	**目标：** 实现视觉识别目标 → 计算目标坐标 → 机械臂规划路径 → 移动。
	
	|目标任务|核心技术栈|实现问题 → 改进措施|
	|---|---|---|
	|**1. 目标识别与 2D 定位**|Python/OpenCV|**问题：** 光线/背景变化影响 OpenCV 颜色/形状识别精度。→ **改进：** 尝试简单的**特征匹配**或未来引入轻量级 **AI 模型**（如 YOLOv5s）。|
	|**2. 机械臂运动学与 URDF**|ROS/URDF|**问题：** 逆运动学解算失败。→ **改进：** **简化机械臂模型**，或使用 ROS 内置的 KDL 库，确保**运动学建模**正确。|
	|**3. MoveIt! 路径规划**|ROS/MoveIt!|**问题：** 规划出的路径撞到自己或工作台。→ **改进：** 精确设置 URDF 中的**碰撞包围盒**，调整 **RRT 规划器参数**。|
	|**4. MoveIt! 与 STM32 对接**|Python/ROS|**问题：** MoveIt! 输出的复杂轨迹，简易 STM32 无法精确跟踪。→ **改进：** 在 ROS 侧对轨迹进行**降采样**，简化为一系列目标点，由 STM32 **位置环 PID** 逐个跟踪。|
	
	### 阶段三：高层决策与系统集成闭环
	
	**目标：** 将所有模块用一个高层逻辑串联起来，实现自主任务。
	
	|目标任务|核心技术栈|实现问题 → 改进措施|
	|---|---|---|
	|**1. 高层任务逻辑**|Python 或 ROS 行为树|**问题：** 逻辑分支混乱、代码难以维护。→ **改进：** 使用**有限状态机 (FSM)** 或 **行为树**来清晰定义**巡逻、发现目标、抓取、返回**等任务状态。|
	|**2. 底盘导航集成**|ROS Navigation Stack|**问题：** 导航 Demo 机器人在角落卡住。→ **改进：** 优化 DWA **局部规划器的参数**，调整安全裕度。|
	|**3. 整体系统鲁棒性**|C/C++/Python|**问题：** 某个环节出错（如视觉卡顿）导致整个系统崩溃。→ **改进：** 引入**看门狗机制**（Watchdog），在 FreeRTOS 和 ROS 上都加入**故障检测**和**安全模式**。|
	
		---
	
	**最终目标：** 用这套系统实现一个简单的 **“自主抓取和放置”** 任务，形成一个可以写入简历的完整项目。后续所有硬件和算力的升级，都只是用来优化这套架构中的**控制精度、规划速度和感知鲁棒性**，架构和算法思维则保持不变。
	
2. [分支 · 从串口到rosserial再到micro-ROS的渐进式上下位机通信学习路线](https://chatgpt.com/c/68db95b7-5a84-8321-a28d-68197f61706c)
	1. 太好了 — 我把 **从零到上场（Robocon 可落地）** 的全栈学习路线做成一份详细、系统、可执行的路线图。每个主干（STM32/嵌入式、机器人学/ROS、Python、C/C++）都拆成子分支、学习目标、实战任务、工具/硬件/参考资源、验收指标与延伸方向。你可以把它当作半年~一年（按个人节奏可拉长/压缩）的学习蓝图，每一步都尽量给出可以立刻执行的练习、产出与检查点。
	
	# 总体思路（如何使用这张路线图）
	
	- 按模块并行学习：底层（STM32）为核心先手，ROS/上层与视觉并行推进。
	    
	- 每学会一个知识点，做一个小项目（产出代码 + README +录像）。
	    
	- 把项目模块化：驱动层→控制层→感知层→策略层→仿真/上位机。
	    
	- 频繁测试与测量：用示波器/逻辑分析仪/串口可视化验证硬件。
	    
	- CI/版本控制从一开始用（git + branch + code review）。
	    
	
	---
	
	# 一、STM32 / 嵌入式（底层：硬件驱动 × 实时控制）
	
	目标：能够独立完成传感器驱动、马达驱动、CAN/UART通信、RTOS 任务、闭环控制与电源管理。
	
	## 核心技能与知识点（分级）
	
	### 基础（掌握）
	
	- C 基础（数据类型、指针、数组、结构体、位运算、内存布局）
	    
	- STM32 工具链：STM32CubeMX / STM32CubeIDE（或 Keil、PlatformIO）
	    
	- GPIO、UART、Timer、ADC、PWM 的使用与调测
	    
	- 串口通信（ASCII 与二进制协议设计）
	    
	- 使用 ST-LINK 烧写与调试（断点/寄存器/变量查看）
	    
	- 简单电路基础：供电、去耦、电平、接地、分压
	    
	
	**练习与产出**：
	
	- CubeMX 生成工程：点灯、按键、UART 打印、ADC 读取电位器、PWM 控制 LED 亮度
	    
	- README + 烧录说明 + 演示视频
	    
	
	### 进阶（必须）
	
	- 中断机制、NVIC、优先级
	    
	- DMA（ADC/DMA、UART DMA）与 zero-copy 思想
	    
	- 定时器高级（输入捕捉、编码器接口、PWM）
	    
	- PID 基础实现（离散化、反走样、防积分饱和）
	    
	- 电机驱动接口：H 桥、BLDC 驱动器控制（PWM、死区、过流保护）
	    
	- 编写稳健驱动：初始化/恢复/错误处理（Error_Handler、看门狗）
	    
	
	**练习**：
	
	- 用编码器实现速度闭环（测速→PID→驱动）
	    
	- 用 ADC + 电流传感器实现过流检测 + 看门狗触发
	    
	
	### 高级（Robocon 必备）
	
	- FreeRTOS 实战：任务/队列/二值信号量/互斥/内存池/软件定时器
	    
	- CAN 总线与协议：CAN 消息格式、终端电阻、CANopen 或自定义协议；在 Linux（树莓派）端用 socketCAN 调试
	    
	- 实时问题与分析：优先级反转、死锁、时钟抖动、堆栈配置（如何测栈溢出）
	    
	- 电源管理：LDO vs DC-DC，去耦、EMI、单点接地、分域供电
	    
	- Bootloader（DFU 或串口/USART/Can 升级）
	    
	- 安全保护：软件看门狗、硬件看门狗、紧急停止（E-stop）
	    
	
	**练习**：
	
	- 使用 FreeRTOS 实现任务间通信：传感器采集任务、控制任务、通信任务
	    
	- 实现 CAN 主从架构：主控下位控制多个电机驱动模块
	    
	- 自建 bootloader 或使用开源 bootloader
	    
	
	## 常用硬件（建议）
	
	- MCU：STM32F4（F407）、STM32H7（更高性能）作为主控；STM32F103 用于学习/次级控制
	    
	- 调试：ST-LINK V2/V3、JLink（可选）
	    
	- 电调/驱动：BTS7960、DRV8301/DRV8316、常见 BLDC ESC
	    
	- 传感器：MPU9250/ICM-20948（IMU）、增量编码器、霍尔、模拟电流传感器（INA219/INA226）
	    
	- 通信：MCP2551（CAN 收发器）、RS485 收发器（需要时）
	    
	
	## 验收指标
	
	- 可在 STM32 上稳定运行 FreeRTOS（多任务 3~5 个）
	    
	- 马达闭环速度控制误差可 < 指定阈值（取决硬件）
	    
	- CAN 总线下设备通信可靠、重连策略生效
	    
	
	---
	
	# 二、机器人学 / ROS（上层智能与协同）
	
	目标：掌握机器人感知/定位/规划/控制闭环，能用 ROS 把视觉/定位/策略变成机器人动作。
	
	## 核心技能
	
	### 基础
	
	- Linux 基础（命令行、SSH、系统服务）
	    
	- ROS1（Noetic） 或 ROS2（Foxy/Galactic）：节点、话题（topic）、服务、参数、消息（msg）
	    
	- RViz 可视化、rosbag 录制回放
	    
	- TF 坐标变换基础
	    
	- 使用 rosserial / micro-ROS 与 STM32 通信（话题形式上报传感器/控制指令）
	    
	
	### 感知 / 视觉
	
	- OpenCV（图像预处理、轮廓、HSV 颜色分割、模板匹配）
	    
	- 目标检测：YOLO/SSD（训练流程、标签工具、迁移学习）
	    
	- 相机标定与畸变校正（OpenCV camera calibrate）
	    
	
	### 定位与导航
	
	- 里程计 + IMU 融合（扩展卡尔曼滤波 EKF）
	    
	- SLAM：gmapping / cartographer（激光）或 ORB-SLAM（视觉）
	    
	- move_base / Nav2：全局/局部路径规划、AMCL，自定义局部规划器
	    
	
	### 控制与策略
	
	- 速度控制、位置控制的高层策略（速度分配、轨迹跟踪）
	    
	- 行为树 / 状态机：smach、behavior tree（行为编排）
	    
	- 算法：PID、LQR、MPC（深入）
	    
	
	## 实战项目（分阶段）
	
	1. ROS 环境搭建 → 发布 / 订阅模拟数据（TurtleSim → 自定义消息）
	    
	2. rosserial + STM32：STM32 发布编码器速度，上位机订阅并在 rviz 中显示
	    
	3. 使用激光雷达做 slam 与导航：从建图到自动导航
	    
	4. 视觉定位：相机检测目标，发布目标位姿，上位机下发跟随指令
	    
	5. 将策略整合：视觉→定位→路径→控制 → 在真实车上实现任务
	    
	
	## 工具与仿真
	
	- Gazebo（物理仿真）、RViz（可视化）
	    
	- MoveIt!（机械臂规划）
	    
	- rosbag（数据记录）、rqt（调试面板）
	    
	
	## 验收指标
	
	- 能用 ROS 控制 STM32 驱动的机器人完成点到点导航（在场地内）
	    
	- 能实现目标检测→位置估计→控制闭环（视觉引导任务）
	    
	
	---
	
	# 三、Python（数据处理、视觉、工具链）
	
	目标：能训练视觉模型、快速搭建调试工具与上位机脚本。
	
	## 核心技能
	
	- Python 基础：函数、模块、asyncio、装饰器、虚拟环境（conda）、包管理
	    
	- 数据科学基石：numpy/pandas、matplotlib、scipy
	    
	- OpenCV 实战：图像读写、滤波、边缘、轮廓、ROI、相机标定
	    
	- 深度学习入门：
	    
	    - PyTorch 或 TensorFlow：模型构建、训练循环、优化器、保存/加载模型
	        
	    - YOLOv5/YOLOv8 或 YOLOX：训练/微调流程、数据增强、评估（mAP）
	        
	- 模型部署：
	    
	    - ONNX/TensorRT 加速（若使用 Jetson）
	        
	    - OpenVINO（Intel Edge）或 NCS
	        
	
	## 实战任务
	
	- 写上位机串口收发+数据可视化（pyqtgraph）工具（实时调试）
	    
	- 从头做一个 YOLO 目标检测：数据标注（LabelImg）→ 训练→ 导出→ 在树莓派/Jetson 上运行
	    
	- 撰写简单的自动标注/增强脚本（旋转、色彩偏移、MixUp）
	    
	
	## 验收指标
	
	- 能独立训练并部署一个轻量检测模型到边缘设备（Raspberry Pi/Jetson）
	    
	- 能快速写串口调试工具并画出实时波形/日志
	    
	
	---
	
	# 四、C / C++（嵌入式质量代码与性能提升）
	
	目标：写出性能稳定、可维护的驱动与 ROS 节点（C++）。
	
	## C（嵌入式侧）
	
	- 指针与内存管理、volatile、内存对齐
	    
	- 链表/环形缓冲区实现（串口 DMA 环形缓冲）
	    
	- 固件设计模式：驱动抽象、硬件抽象层（HAL 封装）
	    
	- 单步调试、寄存器级排查
	    
	
	## C++（上层/ROS）
	
	- Modern C++（11/14/17）：智能指针、移动语义、lambda、线程库
	    
	- RAII、异常安全（嵌入式慎用异常）
	    
	- roscpp 节点开发、服务与 Action
	    
	- 性能调优（profile、内存使用、异步 I/O）
	    
	
	## 工具链
	
	- 编译器：arm-none-eabi-gcc、GCC / Clang（上位C++）
	    
	- 静态分析：cppcheck、clang-tidy
	    
	- 格式化：clang-format
	    
	- 单元测试：GoogleTest（上位），Unity/Cmock（嵌入式）
	    
	
	---
	
	# 五、完整落地项目路线（里程碑式）
	
	每个里程碑产出应包含代码、文档、测试步骤、演示视频。
	
	## 里程碑 0：基础准备
	
	- 环境搭建：STM32CubeIDE/Keil、Miniconda、ROS、Git
	    
	- 硬件清单与电源测试
	    
	
	## 里程碑 1：底层打桩 & 通信
	
	- MCU：点灯、ADC、UART、串口协议（ASCII & 二进制）
	    
	- PC：串口工具 + 实时绘图脚本  
	    **验收**：PC 能实时显示 ADC 波形
	    
	
	## 里程碑 2：电机驱动与闭环
	
	- 把电机接入，编码器读数，PID 调速  
	    **验收**：速度跟踪误差在阈值内，抗扰动
	    
	
	## 里程碑 3：RTOS & 多节点
	
	- 在 STM32 上用 FreeRTOS 实现采集/控制/通信任务  
	    **验收**：任务调度稳定，优先级正确
	    
	
	## 里程碑 4：上位机 ROS 集成
	
	- rosserial / micro-ROS 与 STM32 通信
	    
	- 在 RViz 上可视化里程计/IMU数据  
	    **验收**：上位机能发命令控制底盘并收到回报
	    
	
	## 里程碑 5：感知与导航
	
	- 相机识别目标（YOLO）→ 上位机定位 → 控制器执行
	    
	- SLAM + 路径规划  
	    **验收**：机器人能自动完成场地指定任务
	    
	
	## 里程碑 6：比赛整合与优化
	
	- 比赛策略实现、场地测试、性能调优、冗余与安全  
	    **验收**：在演练赛中稳定完成任务
	    
	
	---
	
	# 六、工程实践与最佳实践（必须长期坚持）
	
	- 版本控制：feature-branch + PR + tag（重要版本）
	    
	- 文档：每个模块 README、接口说明、通信协议文档（消息定义）
	    
	- 单元测试与回归测试：关键算法写测试（PID、滤波）
	    
	- 数据记录：rosbag、csv、日常日志用于离线分析
	    
	- 仿真优先：在 Gazebo 上迭代算法，降低风险
	    
	
	---
	
	# 七、参考书和资源（推荐）
	
	- C 与 嵌入式：K&R《C程序设计语言》、Dominik 的《Mastering STM32》/《STM32CubeMX 实战》
	    
	- RTOS：FreeRTOS 官方教程 + 《嵌入式实时操作系统》
	    
	- 机器人学：Thrun / Burgard《Probabilistic Robotics》、Siciliano《Robotics, Modelling, Planning and Control》
	    
	- ROS：官方 ROS 教程（ROS wiki），《Programming Robots with ROS》
	    
	- 视觉/深度学习：OpenCV 官方文档，PyTorch 教程，YOLO 官方仓库（训练/迁移学习）
	    
	
	---
	
	# 八、硬件采购建议（入门→进阶）
	
	- 入门：STM32F103 / Nucleo-F4 / BluePill、USB-TTL、单电机驱动、编码器、IMU
	    
	- 进阶：STM32F4/F7/H7、Raspberry Pi 4、Jetson Nano/Xavier、CAN transceiver、Lidar（RP Lidar / RPLIDAR A1）、RealSense 摄像头
	    
	- 电源：高品质 LDO 或 DC-DC，10–20 A 供电视负载
	    
	
	---
	
	# 九、学习节奏（示例）
	（可按周/月灵活调整；每阶段以“产出”为目标 — 一个小项目或 demo）
	
	1. 周 1–4：C + STM32 基本外设（GPIO/UART/ADC/PWM）→ 小车原型搭建
	    
	2. 周 5–8：编码器 + PID + 电机驱动 → 闭环小车行驶
	    
	3. 周 9–12：FreeRTOS、CAN、串口协议 → 多节点协作
	    
	4. 周 13–20：ROS 入门 + Gazebo 仿真 + rosserial → 上位机控制
	    
	5. 周 21–28：视觉（OpenCV→YOLO 训练）+ Jetson 部署 → 视觉引导任务
	    
	6. 周 29+：整合、优化、策略与比赛演练
	    
	
	---
	
	# 十、我可以立刻帮你的事情（你要的话）
	
	- 给你定制 **6~12 周详细计划表**（每天/每周任务 + 练习 + 检查清单）
	    
	- 给某个里程碑写 **可直接烧录的示例代码**（STM32：ADC+D MA+UART；FreeRTOS 任务模板；或 ROS↔STM32 通信 demo）
	    
	- 给 **视觉训练脚本**（基于 YOLOv5/YOLOv8）从标注到导出 ONNX 的完整 pipeline
	    
	- 帮你审核比赛策略，把高风险点与测试清单列出来
	    
	
	你想先从哪一部分深挖？（例如：STM32 电机闭环示例 + FreeRTOS 模板，还是 ROS 与 STM32 的串口/CAN 对接样例，或 YOLO 训练与部署流程？）我马上把对应的**详细步骤 + 代码样例 + 测试方法**给你。
